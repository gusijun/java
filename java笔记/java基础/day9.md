##### 匿名对象：

​         1.匿名对象:创建类的对象,但是并没有声明给一个对象引用

​         2.匿名对象只能调用一次

​         3.应用，常常在调用方法时，将一个匿名对象作为参数传递过去



##### 方法重载：（overload） loading...

​     1.定义：在同一个类中，相同的方法名，不同的参数列表的方法之间，彼此构成重载

​      举例：Arrays 中的sort（Xxx[] xxx） / System.out.println(Xxx xxx)

​      总结：两同一不同，一不同：①参数个数不同   ②参数类型不同

​    2.方法的重载与方法的形参的变量名没有关系！ 与方法是否有返回值也没有关系

 测试题：区分方法的重载（overload）和方法的重写（override / overwrite）           

​     3.如何确定调用的是哪一个类的方法？ 指明方法名------>指明参数的类型



可变个数形参方法的使用：jdk5.0新特性

   1.可变个数形参的格式：数据类型  ... 变量名

   2.可变个数形参的方法在调用时，给可变个数的形参赋值时，可以赋值的个数为：0个，1个，........

   3.可变个数形参的方法与同名方法之间彼此构成重载

   4.可变个数形参的方法与形参类型相同的数组方法不能同时出现在类中

5. 可变个数形参必须声明方法形参的最后一个参数

6.   在一个方法的形参位置，最多只能声明一个可变长度形参

   

##### 变量的值传递机制：

​    如果赋值的是基本数据的变量，则传递的是基本数据类型变量所保存的具体的数值

​    如果赋值的是引用数据类型变量，则传递的是引用数据类型变量所保存的地址值



#####  方法的参数传递机制：值传递

​     1.形参：方法在声明时，指定的参数

​        实参：方法调用时，具体给形参赋的值，就是实参

​      2.如果方法的形参是基本数据类型的变量，则方法调用时，传递的实参即为基本数据类型变量所保存的具体的值 

​         如果方法的形参是引用数据类型的变量，则方法调用时，传递的实参即为引用数据类型变量所保存的地址值

​          



面向对象的特性之一：封装与隐藏 3w : what ？ why ? how ?

1.问题的引入？

   我们在创建一个类的对象以后，通过“对象.属性”的方式，可以给对象的属性赋值，对此属性的赋值，是有限制的，比如：数据类型和数据类型储存范围的限制。

但在实际问题中，还通过需要额外的限制。同时这些额外的限制，不可能在属性的声明中加上限制逻辑。

那抹我们只能考虑通过方法，对属性的赋值进行额外的限制，同时，我们必须禁止再直接通过 “对象.属性” 的方法，对属性进行赋值

2.封装性的体现(狭义上的体现)

​      私有化(private)类的属性，同时，提供公共的(public)设置(setXxx())和获取(getXxx())的方法

3.封装性的体现：（广义上的体现）

​    java规定的4种权限修饰符：（从小到大） private 缺省  protected   public 

​    java规定的4种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类

​    具体来讲：这4种权限都可以用来修饰类的内部结构：属性，方法，构造器，内部类，只能使用 缺省 或者 public 修饰类



