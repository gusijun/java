面向对象的特性之二: 继承性 what ?  why ? how ? 

​     1.继承性的好处:

​          ①减少了代码的冗余，提高了代码的复用性  

​          ②更好的扩展性   

​          ③为多态的使用提供了前提 

​    2.格式:class A extends B  extends:继承,(延展,扩展)      子类(SubClass):A      父类(SuperClass,超类,基类):B  

​    3.说明:子类A继承父类B以后,就获取了父类中声明的结构:属性，方法 

​            3.1 不管父类中的属性或方法或权限如何，子类都可以获取到  

​            3.2 但是由于封装性的影响,可能在子类中不能直接调用父类中的权限较小的属性或方法

​    4.子类可以可以在继承父类的基础之上,提供自己特有的属性和方法    

​            区别于:集合与子集   

​    5.子类和父类是相对的概念      

​      子类通过继承，可以获取直接父类以及所有的间接父类中声明的所有属性或方法    

​     一个父类可以被多个子类所继承   

​     子类只能声明一个父类---->java类的单继承类



6.

   6.1 如果一个类没显示的继承一个类的话，则其父类为：java.lang.Object类 

   6.2 任何一个类(java.lang.Object 类)都能直接或者间接的继承于java.lang.Object类 

   6.3 任何一个类在继承java.lang.Object 之后，就获取了Object类中声明的属性和方法



方法的重写(override / overwrite)   

​        1.定义:子类在继承了父类以后，可以对父类中的同名同参数的方法进行“覆盖”或“覆写”

​        2.重写以后，如果我们创建子类的对象，通过子类的对象调用子父类中同名的方法，执行的的是子类重写父类的方法  

​         3.子类重写的方法，父类被重写的方法      

​               方法的声明:权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ }   

​               子类重写的方法与父类被重写方法的方法名和形参列表相同    

 ​              子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符     

​               特别的，子类不能重写父类中声明private的方法(因为子类中看不到)       

​               子类重写方法的返回值类型 不大于父类被重写方法的返回值类型        

​               举例: 1.父类方法的返回值类型是void，子类想重写，一定也是void  

​                         2.父类方法的返回值类型是A，子类重写父类方法，返回值是类型A或类型A的子类，不能是类型A的父类       

​              子类重写的方法抛出的异常类型不大于 父类被或重写方法抛出的异常类型  

******************************

​         规则: 子类与父类中同名同参数的方法，必须同时声明为static(不是重写)或非static（即为重写）





super 关键字的使用:   

​      1.super 理解为:父类的    

​      2.super 可以用来调用属性,方法,构造器    

​      3.super属性,方法

​            3.1 有了继承以后我们可以在子类的方法或者构造器中，可以通过“super.属性”或者“super.方法”的方法,显示的调用父类中声明的属性或者方法。但是很多情况下，我们都可以省略“super.” 

​            3.2 如果子类和父类中出现了同名的属性，那抹我们在子类中调用父类同名的属性的的话，必须使用“super.”的方法      

​                  说明:子类的属性不会覆盖父类中同名的属性。在堆空间中，两个属性都会存在     

​            3.3 如果子类重写了父类的方法，那抹我们在子类中调用父类被重写的方法，必须用“super.”的方法

   4. super 调用构造器: super(形参列表)  

      ​       4.1 在子类的构造器的首行，显示的使用“super(形参列表)”的方式,调用父类指定的构造器  

      ​       4.2 针对于子类的某一个构造器而言，最多只能声明一个“super(形参列表)”  

      ​       4.3 在子类的构造器的首行，要抹使用“this(形参列表)”,要抹使用“super(形参列表)”,不能同时出现    

      ​       4.4 在子类构造器的首行，既没有显示的使用"this(形参列表)"，也没有显示的使用“super(形参列表)”，那抹默认提供的是：“super()”       

      ​       4.5 在子类的多个构造器中，至少有一个构造器的首行使用了“super(形参列表)”



子类对象实例化的全过程： 

​     1.结果上:(继承性)      子类在继承父类以后，就获取了所有的父类中声明的属性和方法  

​     2.过程上:      我们在实力化子类对象的过程中，一定会直接或间接调用父类的构造器，以及父类的父类的构造   

​                          器....      直到调用到java.lang.Object的空参构造器，正因为加载了这些父类的结构，所以,在子类对

​                          象的内存中才有所有父类中声明的属性或方法  

​           说明:在子类对象整个实例化过程中，只创建了唯一的一个对象，即为当前的子类对象

​    



面向对象的特征三:多态性的使用 

​     1.多态性:可以理解为一个事物的多种形态   

​     2.广义上多态性的体现:  

​          ①方法的重写和重载      ②子类对象的多态性    

​     3.狭义上多态性的体现: 子类对象的多态性  

​     4.子类对象的多态性:父类的引用指向子类的对象(子类的对象赋给父类的引用)   

​     5.多态的应用场景      

​           虚拟方法调用:编译时,认为调用的方法是父类的,但是当运行时，实际上执行的是子类重写父类的方法   

​          总结:多态中方法的调用:编译看左边，运行看右边。

​    6.多态性,只适用于方法 !

​    7.多态性使用的前提:①类的继承关系 ②要有方法的重写

​     