方法覆盖：overrride ,overwriter
	1.什么时候方法需要重写？
		如果父类中的方法已经无法满足当前子类的业务要求，需要将父类的方法进行重写
	2.子类如果重写父类中的方法之后,子类对象一定调用的是重写之后的方法。
	3.发生方法覆盖的条件：
		第一：发生在具有继承关系的两个类之间
		第二：必须具有相同的方法名,相同的返回值类型,相同的参数列表
		第三：重写的方法不能比被重写的方法拥有更低的访问权限
		第四：重写的方法不能比被重写的方法抛出更宽泛的异常
		第五：私有的方法不能被覆盖
		第六：构造方法无法被覆盖，因为构造方法无法被继承
		第七：静态的方法不存在覆盖
		    （静态方法执行和对象无关）
		第八：覆盖指的是成员方法，和成员变量无关

   4.继承的基本作用：代码复用。继承最重要的作用：方法重写

   关于java语言中向上转型和向下转型
	 	1.向上转型(upcasting):  子 --> 父
		 2.向下转型(downcasting):父 --> 子
		

 注意：无论是向上转型还是向下转型,两个类之间必须有继承关系



多态作用：使用多态可以使代码之间的耦合度降低
				   项目扩展能力增强
耦合度：代码和代码之间的关联程度

super
    1.super不是引用类型，super中存储的不是内存地址,super指向的不是父类对象
    2.super代表的是当前子类对象中的父类型特征
    3.什么时候使用super？
	    子类和父类中都有某个数据,例如,子类和父类中都有name这个属性
	    如果要在访问子类中父类中的属性，需要使用super
    4.super可以用在什么地方？
	成员方法
	构造方法

super关键字用在构造方法中：
语法:super(实参)；
作用：通过子类的构造方法去调用父类的构造方法

语法规则：一个构造方法第一行如果没有this(...)，也没有显示的去调用super(...);
	  系统会默认调用super();
注意：super（...）的调用只能方在构造方法的第一行
super(...)和this(...)不能共存



通过子类的构造方法去调用父类的构造方法：作用是：给当前子类对象中的父类型特征赋值。

如何定义抽象类？
    1.class关键字前abstract
    2.抽象类无法实例化
    3.虽然抽象类没有办法实例化,但是抽象类也有构造方法，该构造方法是给子类创建对象的用的
    4.抽象类中可以定义抽象方法：
	抽象方法的语法：在方法的修饰列表中添加abstract关键字,并且抽象方法应该以“；”结束,不能带有“{}”
	例如：public abstract void m();
    5.抽象类中不一定有抽象方法，但抽像方法所在的类必须是抽象类
    6.一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，实现，重写。

  抽像类不能被final修饰
  抽象方法不能被final修饰

final修饰的类无法被继承
final修饰的方法无法被重写
final修饰的局部变量一旦赋值不可再改变
final修饰的成员变量需要手动赋值
final修饰的成员变量和static联用称为常量
深入final
     final修饰的引用类型,该引用不可重新指向其他的java对象
     但是final修饰的引用,该引用指向的对象的属性是可以修改的
     
	