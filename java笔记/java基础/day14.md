单例设计模式:

   饿汉式

   懒汉式



类的成员之四:代码块(或初始化块)    

  1.代码块的使用:用来初始化类,对象的信息     

  2.代码块的分类:静态代码块 vs 非静态代码块    

  3.静态代码块:   

​         &gt;可以提供输出语句 

​         &gt;随着类的加载而执行,且只被加载一次  

​         &gt;使用:初始化类的加载信息        

​         &gt;内部只能调用当前类中静态的属性,方法。不能调用非静态的属性,方法   

​         &gt;如果定义了多个静态代码块，按照定义的先后顺序执行        

​         &gt;静态代码块执行的顺序要早于非静态代码块    

   非静态代码块:         

​        &gt;随着对象的创建而执行         

​        &gt;每创建对象，都会执行一次               

​        &gt;使用:初始化对象的属性         

​        &gt;内部可以调用静态的:属性,方法。也调用非静态的属性,方法         

​        &gt;如果定义了多个非静态代码块，按照定义的先后顺序执行         

​        &gt;非静态代码块执行的顺序要晚于静态代码块    

  4.给属性赋值的位置的先后顺序:        

​       ①默认初始化     

​       ②显示初始化 / 在代码块中初始化     

​       ③构造器中初始化      

​       ④有了对象以后,通过“对象.属性”或“对象.方法”的方法,赋值



final关键字的使用:    

​     1.final:最终的  

​     2.final可以来修饰:变量,方法,类  

​     3.final修饰类:此类不可以被继承,比如String / StringBuffer类   

​     4.final修饰方法:此方法不能被重写，比如Object类的getClass 

​     5.final修饰变量:此变量就是一个常量。比如:Math类中的PI    

​         5.1 使用final修饰属性,可以考虑的位置有：  

​            ①显示初始化      

​            ②代码块中 

​            ③构造器中     

​       5.2使用final修饰形参,在方法调用时,在方法调用时,传递实参,给变量赋值，一旦复制,方法内不可以修饰常量的值      

static final:所修饰的属性,称为全局常量



abstract关键字的使用:  

​    1.abstract :抽象的  

​    2.可用来修饰的结构:类,方法  

​    3.abstract修饰类:抽象类    

​            &gt;不可实例化    

​            &gt; 仍然存在构造器。构造器的作用:便于子类实例化时进行调用    

​            &gt;通常情况下,我们会提供抽象类的子类,让子类实例化,调用父类的结构。    

​            &gt;抽象类中不一定有抽象方法;抽象方法所在的类，一定是抽象类 

   4.abstract修饰方法:抽象方法(没有方法体)    

​          &gt;如果子类重写了父类的所有抽象方法，则此子类可以实例化    

​          &gt;如果子类没有重写父类的所有抽象方法，则子类仍为抽象类  

   5.前提:抽象性使用的前提是类的继承性。

   模板方法的设计模式



接口的使用: 

​       1.接口(interface) 是与类(class)并列的结构 

​       2.如何定义一个接口,使用interface关键字 

​       3.接口中只能定义常量和抽象方法----->JDK7.0及以前版本(JDK8.0接口中引入默认方法,静态方法)

​          常量的定义:public static final修饰 

​          抽象方法的定义: public abstract修饰 

​      4.接口中不能声明构造器！接口不可以直接实例化的 

​      5.类与接口之间的关系:实现(implements)关系,实现接口以后，就获取了接口中声明的结构:常量,抽象方法。

​         格式:class SubClass extends SuperClass implements InterfaceA 

​     6.类实现接口以后,要抹实现接口中的所有抽象方法,方可实例化          

​                                    要抹当前类声明为抽象类(因为内部包含从接口中获取的抽象方法)

​      7.java规定:类可以实现多个接口----->一定程度上,解决了java类的单继承的局限性 

​      8.java规定:接口与接口之间是继承关系,而且是可以多继承！



接口的使用: 

   1.接口与具体的实现类之间存在多态性  

   2.如何提供接口的匿名实现类,如何去创建匿名对象

   3.接口,实际上可以理解为定义了一套相应的功能的规范,标椎



接口的应用:

   &gt;工厂模式

   &gt;代理模式



java8规范:  接口可以定义静态方法,默认方法

​         ①知识点1:接口中定义的静态方法,只能通过接口进行调用

​         ②知识点2:通过实现类的对象,调用接口中的默认方法

​         ③知识点3:如果类实现的接口和父类中,定义了同名同参数的方法,那抹子类在没有重写此方法的情况下，

​                            默认调用的是父类中声明的方法。-----“类优先”原则

​          ④知识点4:如果实现类实现了多个接口,接口中定义了同名同参数的方法，那抹此时对于实现类来讲,会出现接  

​                             口冲突问题。

​                             解决方法:要求实现类必须重写接口中的方法。

​          ⑤知识点5:如何在实现类的方法中调用接口中的默认方法

​                              接口.super.方法()





类的成员之五:内部类(InnerClass)  

 1.定义:java语言在一个类A的内部再定义了一个类B。   

​             将类B:称作内部类；类A:外部类  

 2.内部类,作为一个类:              

​         &gt;内部可以定义属性,方法,构造器等            

​         &gt;可以被final修饰            

​         &gt;可以被abstract修饰       

​                 作为外部类的一个成员:          

​          &gt;可以被4种不同的权限修饰            

​          &gt; 可以被static修饰              

​         &gt;可以调用外部类的结构:属性,方法等   

  3.内部类的分类:成员内部类（静态的;非静态的）  vs 局部内部类  

  4.需要掌握的知识点:    

​     4.1 如何创建成员内部类的对象？   

​     4.2 如何调用外部类的结构？    

​     4.3 关于局部内部类在开发中的体现



部内部类的方法中调用局部内部类所在方法中定义的局部变量，要求此局部变量声明为final的。

在java7及以前的版本中，需要显示的声明为final。

在java中可以省略final的声明

