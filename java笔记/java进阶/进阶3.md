关于方法的重载(overload)
优点：
	1.程序员只需要记忆很少的方法名,方便调用
	2.代码更加关注
什么时候发生方法的重载：
	1.发生在同一个类中
	2.方法名不同
	3.参数列表不同(类型,个数,顺序)
	
方法的重载和方法的返回值以及形参名无关

方法的执行原理:
	方法在调用的时候,才会给该方法在内存中分配空间
	如果这个方法只是定义没有调用,则不会在内存中分配空间
	

方法调用的时候在“栈”中分配空间,(JVM)内存中有一块内存是栈结构
方法调用其实就是“压栈”
方法结束其实就是“弹栈”

关于方法的递归调用
	1.方法的递归调用就是方法自身调用自身


类：一类具有相同特征的事物构成的集合
    把现实世界中的抽象化
实例：类的具体化

OOA   面向对象的分析
OOD   面向对象的设计
OOP   面向对象的编程

JVM中所有new出来的数据统一被储存在堆区中，程序员是无法对堆区数据直接操作，
只能通过内存地址间接访问

访问成员变量或者成员方法必须使用“引用.”(成员变量属于对象级的)

面向对象的封装性指的是：
	1.属性私有化
	2.对外部提供公开的setter,getter

​	 set和get方法的方法名应该遵循规范



关于java类的构造函数
	1.构造方法语法
	[修饰符列表] 构造方法名[形式参数表]{
		方法体
	}
	2.构造方法的方法名必须要类名一致
	3.构造方法的作用是什莫？
		第一:创建对象
		第二：初始化对象的属性
	4.构造方法应该如何调用？
	   new 构造方法名(实参)； 在堆中开辟空间储存对象
        5.如果一个类没有提供任何构造方法，系统会默认提供无参构造方法
	  如果一个类已经手动提供了构造方法，那抹系统不再提供任何构造方法
	6.成员变量到底什么时候赋值？
		只有在调用构造方法的时候，才会给成员变量赋值

GC垃圾回收机制主要针对堆中的数据，当没有更多的引用指向时，则会被垃圾回收机制
如果使用空的引用去访问，则会出现空指针异常

参数传递的问题：
	1.传递的数据是基本数据类型 （值）
	2.传递的数据是引用数据类型 （地址）

this关键字：
	1.this是什么？
	  this是一个引用类型
	  在堆中java的每个对象中都有一个this，保存地址指向当前对象
	2.this能用在哪些地方？
	  构造方法，实例方法
	

this可以用来区分成员变量和局部变量

​    this不能出现在静态方法中：
​     静态方法的执行根本不需要java对象的存在,直接使用 类名.方式的访问
​     而this代表的是当前对象,所以静态方法中根本没有this

static关键字：
	1.static修饰的变量叫做"静态变量"
	2.static修饰的方法叫做"静态方法"
	3.static还可以定义静态语句块
   static定义的静态语句块在类加载阶段执行,并且只执行一次，并且是自上而下的顺序执行

   关于实例语句块：
	每一次调用构造方法之前会执行一次
	实例语句块执行顺序也是自上而下

   static修饰的方法叫做静态方法
	静态方法正规方式访问："类名."方式调用
	一般情况下工具类中的大部分方法都是静态方法
	静态方法不用创建对象也能直接访问该方法
	静态方法中不能直接访问非静态数据
	静态方法中不能使用this
       ！！静态方法也能使用“引用.”访问,在编译阶段检查出类型,运行的时候仍然使用"类.调用"
	
   static修饰的变量叫做“静态变量”
	方法区
   什么时候变量声明为静态变量？
	如果这个属性所有的对象都有,并且这个属性的值是相同的，则该属性声明成静态的属性
	静态变量储存在方法区，所有的java对象共享这一份
	所以静态变量是类级别的，使用“类名.”的方式访问

  单例设计模式：
	1.构造方法私有化
	2.对外提供一个公开的静态的获取当前类型对象的方法
	3.提供一个当前类型的静态变量

  单例设计模式分为两种：
	懒汉式
	饿汉式


继承：
  	引入类继承基本的作用：代码复用
	语法：
		[修饰符列表] class 子类名 extends 父类名 {
			类体
	}	
java语言单继承
java语言中子类继承父类,会将父类中所有的数据全部继承,包括私有的也能全部继承过来
但是在子类中无法直接方法父类中的私有数据，但是可以间接的访问。
注意：构造方法无法被子类继承